
#### 1  Python / FastAPI Coding Rules
* **Functions over classes**.
* **Full type hints**; validate with **Pydantic v2** models. Use `typing` for complex types.
* **RORO** pattern (receive object, return object).
* `lower_snake_case` for files/dirs; verbs in variables (`is_valid`, `has_permission`).
* Guard-clause error handling; early returns over nested `else`.
* Raise `HTTPException` for expected errors; log + wrap unexpected ones.
* **Docstrings**: Use Google-style for all public functions/classes.
* **Constants**: Define in `app/constants.py` or module-level UPPER_CASE.
* Folder layout:
  app/
    routers/      # route groups
    models/       # Pydantic + DB models
    schemas/      # request/response schemas
    services/     # business logic layer
    repositories/ # data access layer
    utils/        # pure helpers
    types/        # shared type aliases
    middleware/   # custom middleware
    dependencies/ # FastAPI dependencies
    exceptions/   # custom exceptions
    static/
    tests/        # pytest test files
  logs/           # holds all log files
  scripts/.       # holds all scripts     
---
#### 2  FastAPI Best Practices
* Use **lifespan** context, not `startup/shutdown` events.
* Inject DB/session with dependencies; use `Annotated` for cleaner signatures.
* Middleware order matters: logging → tracing → CORS → error capture.

---
#### 3  Code Quality & Safety
* **No hardcoded secrets**; use `pydantic-settings` for config management.
* **Input validation**: Always validate at boundaries (API, external services).
* **SQL injection prevention**: Use parameterized queries, never f-strings.
* **Graceful degradation**: Circuit breakers for external services.
* **Error context**: Include request IDs, user context in error logs.

---
#### 4  Testing Requirements
* **Write tests for all new functionality** in `app/tests/` using idiomatic pytest.
* Test structure mirrors app structure: `tests/routers/`, `tests/services/`, etc.
* Test file naming: `test_<module_name>.py`.
* **Test categories**:
  - Unit tests: isolated function/class testing
  - Integration tests: API endpoints with test DB
  - Contract tests: external service interactions
* Use pytest fixtures for setup/teardown;
* **TestClient** from FastAPI for endpoint testing.
* Mock external dependencies with `pytest-mock` or `unittest.mock`.
* **Run tests after implementation**: 
  pytest app/tests/ -v  # verbose output

* **Test data**: Use factories or fixtures, never production data.
---
#### 5  Performance & Monitoring
* **Database queries**: Use `select_related`/`prefetch_related` to avoid N+1.
* **Connection pooling**: Configure appropriate pool sizes for DB/Redis.
* **Pagination**: Always paginate list endpoints; use cursor-based for large datasets.

---
#### 6  Dependencies
* **Core**: fastapi, pydantic[email], pydantic-settings, python-multipart
* **Database**: sqlalchemy>=2.0, alembic
* **Testing**: pytest, pytest-cov, httpx, pytest-mock
* **Utils**: python-dateutil
* **External**: httpx (HTTP), google-genai (not google-generativeai)
* Package with **uv**:
  uv add <pkg>
  uv add --dev pytest httpx pytest-mock pytest-cov
  source .venv/bin/activate

---
#### 7  Development Workflow
* **Pre-commit hooks**: `ruff` for linting, `black` for formatting, `mypy` for types.
* **Environment management**: `.env.example` template; never commit `.env`. Use app/core/settings.py and Pydantic to store settings for the app. 
* **Database migrations**: Alembic with descriptive revision messages.
* **OpenAPI**: Customize with tags, descriptions; generate client SDKs.
* **UI**: We use jinja and basic templates to render our html pages, we're not a javascript/react app. 
* **Error responses**: Consistent format with error codes, messages, details.
* We use tailwindcss, you write tailwind css to ./static/css/styles.css and then run `npx @tailwindcss/cli -i ./static/css/styles.css -o ./static/css/app.css` to build the ./static/css/styles.css
---
#### 8  Memory-Bank Workflow (Stateless Agent)
1. **At session start** read:
   `ai-memory/README.md`, `ai-memory/TASKS.md`.
2. **Treat `README.md` as canonical context**.
3. **Maintain `TASKS.md`**:
   * Fine-grained tasks with `- [ ]` / `- [x]`.
   * Include test writing/running as explicit tasks.
   * Group by feature/module for clarity.
   * Last task in every phase → record key learnings before reset.
4. **Propose updates** to memory files whenever you add patterns, finish major work, or clarify requirements.
5. **Missing folder?** Create `ai-memory/`, stub the three files, notify user.
---
#### 9  Memory-Bank File Roles
| File          | Purpose (keep Markdown headers)                                        |
| ------------- | ---------------------------------------------------------------------- |
| **README.md** | Product context, architecture, tech stack, key files, API contracts    |
| **TASKS.md**  | Living checklist (phases, tasks, reference files, learnings, new deps) |
---
#### 10  Updating the Memory Bank
- You MUST review ALL core memory bank files (ai-memory/README.md, ai-memory/TASKS.md) for necessary updates.
- Process:
  1. Execute a suitable command to get a project file listing:
     ```bash
     find . -maxdepth 4 -type f -name "*.py" -o -name "*.md" -o -name "*.yaml" -o -name "*.toml" | grep -v -E "(\.venv|__pycache__|\.git|\.pytest_cache|\.vscode|node_modules|logs|.*egg-info|\.ruff_cache|\.benchmarks|data)" | sort
     ```
  2. Identify key files and folders that need to be explored and add them to the 'Key Repository Folders and Files' section of ai-memory/README.md.
  3. Based on the file listing and recent project activity, identify other key project files (e.g., main application entry points, core modules, critical configuration files) that might require reading or re-reading to ensure ai-memory/README.md (especially 'System Patterns' and 'Tech Context') is comprehensive and up-to-date. Create a ai-memory/TASKS.md file with a list of files and folders to traverse. Include frequent tasks to "update the ai-memory/README.md" as part of the tasks list. Balance reading a group of 3 or 4 files before updating the ai-memory/README.md but waiting too long for updates.
  4. Execute the ai-memory/TASKS.md and check off tasks that are completed. If you identify new key files or folders that need to be read during execution, update the ai-memory/TASKS.md file.
  5. Record architectural decisions, API changes, and performance optimizations in README.md.
  6. Ask the user if there are other folders or files that need to be explored.
---
#### Tools
1. Use `uv add` to add python packages
2. Use `alembic` for database migrations
3. Use `ruff check` and `ruff format` for code quality
4. Use `mypy` for type checking
5. Make sure to ALWAYS run activate before the command. 

**Keep all replies short, technical, and complete.**
```
---
#### 11  Latest Project Structure (Sept 2025)
Use this as the authoritative layout (supersedes earlier sketch if different).

- app/
  - core/            : settings (Pydantic v2), logging, db init
  - routers/         : `content`, `admin`, `logs`, `api_content` (mounted in `app/main.py`)
  - services/        : LLM integrations (OpenAI, Google), event logger, HTTP helpers
  - pipeline/        : sequential task processor, workers
  - scraping/        : unified scrapers (podcast, substack) + runner
  - processing_strategies/: HTML/HN strategies and parsers
  - http_client/     : robust http client with retries
  - models/          : domain models and structured summary
  - repositories/    : data access
  - utils/           : `error_logger.py` (JSONL), misc helpers
  - domain/          : domain-specific entities
  - templates/       : module-scoped views (e.g., favorites)
  - tests/           : unit/integration for routers and pipeline
- templates/         : primary Jinja templates (admin dashboard, logs, lists)
- static/            : tailwind sources and compiled CSS
- scripts/           : start/ops (`start_server.sh`, `start_workers.sh`, `start_scrapers.sh`, `run_*`)
- alembic/ + alembic.ini : database migrations
- docker-compose.yml : server/workers/scrapers with shared logs mount
- Dockerfile.*       : container builds (Playwright deps installed)
- logs/              : JSONL and service logs (host-mounted)

---
#### 12  Key Tools & Services
- Package/venv: `uv` (uses `pyproject.toml` + `uv.lock`).
- Web: FastAPI, CORS, mounted static and templated views.
- Data: SQLAlchemy 2.x, Alembic migrations.
- Settings: `app/core/settings.py` (Pydantic v2, `.env`), required `DATABASE_URL`.
- Workers: `scripts/run_workers.py` via SequentialTaskProcessor.
- Scrapers: `scripts/run_scrapers.py` (cron in Docker uses supercronic).
- LLM: OpenAI client, Tenacity for retries; Google Flash service wrapper.
- Logging: `app/utils/error_logger.GenericErrorLogger` writes JSONL to `logs/errors/*.jsonl` and creates directories automatically.

---
#### 13  Running & Ops
- Dev (local):
  - `uv sync` then `. .venv/bin/activate`
  - Apply DB upgrades: `python -m alembic upgrade head`
  - Start API: `scripts/start_server.sh` (uses uvicorn)
  - Run workers: `scripts/start_workers.sh --stats-interval 60`
  - Run scrapers: `scripts/start_scrapers.sh --show-stats`
- Docker Compose:
  - Services: `server`, `workers`, `scrapers`
  - Shared logs: `./logs:/logs` and `./logs:/app/logs` (both paths map to the same host dir)
  - Up: `docker compose up -d` (use `--build` when Dockerfiles change)
- Supervisor (bare metal): point to `scripts/start_server.sh` and `scripts/start_workers.sh` (see deployment snippet in convo), write logs to `/var/log/newsly/` and symlink `/opt/newsly/logs -> /var/log/newsly` if desired.

---
#### 14  UI & Assets
- Jinja templates under `/templates` with Tailwind CSS.
- Build CSS: `npx @tailwindcss/cli -i ./static/css/styles.css -o ./static/css/app.css`.

---
#### 15  Observability & Logs
- JSONL error logs: `logs/errors/<component>_YYYYmmdd_HHMMSS.jsonl`.
- LLM parse issues: `logs/errors/llm_json_errors.log`.
- Admin views: `/admin/logs` includes JSON and JSONL formatting helpers.
- When running in Docker or Supervisor, ensure `logs/` is writable and shared as above.

---
#### 16  Quick Links (Fast Onboarding)
- Entry
  - `app/main.py` — FastAPI app wiring (routers, CORS, static, health)
- Routers
  - `app/routers/content.py` — public content endpoints
  - `app/routers/admin.py` — admin dashboard and tooling
  - `app/routers/logs.py` — logs list/detail, JSONL formatting, analytics
  - `app/routers/api_content.py` — JSON API under `/api/content`
- Core
  - `app/core/settings.py` — Pydantic v2 settings, `.env`
  - `app/core/logging.py` — root logger/formatter setup
  - `app/core/db.py` — SQLAlchemy engine/session, `init_db()`, migrations helper
- Pipeline & Workers
  - `app/pipeline/sequential_task_processor.py` — main run loop and orchestration
  - `app/pipeline/worker.py` — `ContentWorker`
  - `app/pipeline/podcast_workers.py` — download/transcribe workers
  - `app/services/queue.py` — queue service, `get_queue_stats()`
- Scrapers
  - `app/scraping/runner.py` — orchestrates scrapers
  - `app/scraping/substack_unified.py` — Substack scraping
  - `app/scraping/podcast_unified.py` — Podcast feed/download handling
- HTTP & LLM
  - `app/http_client/robust_http_client.py` — resilient HTTP client with retries
  - `app/services/openai_llm.py` — OpenAI integration, JSON error logging
  - `app/services/google_flash.py` — Google model wrapper, JSON error logging
- Logging Utility
  - `app/utils/error_logger.py` — JSONL error logger (auto-creates `logs/errors`)
- Start/Ops Scripts
  - `scripts/start_server.sh` — migrations + uvicorn
  - `scripts/start_workers.sh` — sequential task processor
  - `scripts/start_scrapers.sh` — scrapers with preflight checks
- Containers & Compose
  - `docker-compose.yml` — shared logs mounts for all services
  - `Dockerfile.server`, `Dockerfile.workers`, `Dockerfile.scrapers`
