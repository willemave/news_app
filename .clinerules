
#### 1  Python / FastAPI Coding Rules
* **Functions over classes**. `def` for sync, `async def` for I/O.
* **Full type hints**; validate with **Pydantic v2** models. Use `typing` for complex types.
* **RORO** pattern (receive object, return object).
* `lower_snake_case` for files/dirs; verbs in variables (`is_valid`, `has_permission`).
* Guard-clause error handling; early returns over nested `else`.
* Raise `HTTPException` for expected errors; log + wrap unexpected ones.
* **Docstrings**: Use Google-style for all public functions/classes.
* **Constants**: Define in `app/constants.py` or module-level UPPER_CASE.
* Folder layout:
  app/
    routers/      # route groups
    models/       # Pydantic + DB models
    schemas/      # request/response schemas
    services/     # business logic layer
    repositories/ # data access layer
    utils/        # pure helpers
    types/        # shared type aliases
    middleware/   # custom middleware
    dependencies/ # FastAPI dependencies
    exceptions/   # custom exceptions
    static/
    tests/        # pytest test files
---
#### 2  FastAPI Best Practices
* Use **lifespan** context, not `startup/shutdown` events.
* Inject DB/session with dependencies; use `Annotated` for cleaner signatures.
* Middleware order matters: logging → tracing → CORS → error capture.
* All DB and external calls are **async**; use `asyncio.gather()` for parallel ops.

---
#### 3  Code Quality & Safety
* **No hardcoded secrets**; use `pydantic-settings` for config management.
* **Input validation**: Always validate at boundaries (API, external services).
* **SQL injection prevention**: Use parameterized queries, never f-strings.
* **Graceful degradation**: Circuit breakers for external services.
* **Error context**: Include request IDs, user context in error logs.
* **Resource cleanup**: Use context managers (`async with`) for connections.
---
#### 4  Testing Requirements
* **Write tests for all new functionality** in `app/tests/` using idiomatic pytest.
* Test structure mirrors app structure: `tests/routers/`, `tests/services/`, etc.
* Test file naming: `test_<module_name>.py`.
* **Test categories**:
  - Unit tests: isolated function/class testing
  - Integration tests: API endpoints with test DB
  - Contract tests: external service interactions
* Use pytest fixtures for setup/teardown; `@pytest.mark.asyncio` for async tests.
* **TestClient** from FastAPI for endpoint testing.
* Mock external dependencies with `pytest-mock` or `unittest.mock`.
* **Run tests after implementation**: 
  pytest app/tests/ -v  # verbose output

* **Test data**: Use factories or fixtures, never production data.
---
#### 5  Performance & Monitoring
* **Database queries**: Use `select_related`/`prefetch_related` to avoid N+1.
* **Connection pooling**: Configure appropriate pool sizes for DB/Redis.
* **Pagination**: Always paginate list endpoints; use cursor-based for large datasets.

---
#### 6  Dependencies
* **Core**: fastapi, pydantic[email], pydantic-settings, python-multipart
* **Database**: asyncpg or aiomysql, sqlalchemy[asyncio]>=2.0, alembic
* **Testing**: pytest, pytest-asyncio, pytest-cov, httpx, pytest-mock
* **Utils**: python-dateutil
* **External**: httpx (async HTTP), google-genai (not google-generativeai)
* Package with **uv**:
  uv add <pkg>
  uv add --dev pytest pytest-asyncio httpx pytest-mock pytest-cov
  source .venv/bin/activate

---
#### 7  Development Workflow
* **Pre-commit hooks**: `ruff` for linting, `black` for formatting, `mypy` for types.
* **Environment management**: `.env.example` template; never commit `.env`.
* **Database migrations**: Alembic with descriptive revision messages.
* **API versioning**: Use `/v1/` prefix; deprecate gracefully.
* **OpenAPI**: Customize with tags, descriptions; generate client SDKs.
* **Error responses**: Consistent format with error codes, messages, details.
* We use tailwindcss, you write tailwind css to ./static/css/styles.css and then run `npx @tailwindcss/cli -i ./static/css/styles.css -o ./static/css/app.css` to build the ./static/css/styles.css
---
#### 8  Memory-Bank Workflow (Stateless Agent)
1. **At session start** read:
   `ai-memory/README.md`, `ai-memory/TASKS.md`.
2. **Treat `README.md` as canonical context**.
3. **Maintain `TASKS.md`**:
   * Fine-grained tasks with `- [ ]` / `- [x]`.
   * Include test writing/running as explicit tasks.
   * Group by feature/module for clarity.
   * Last task in every phase → record key learnings before reset.
4. **Propose updates** to memory files whenever you add patterns, finish major work, or clarify requirements.
5. **Missing folder?** Create `ai-memory/`, stub the three files, notify user.
---
#### 9  Memory-Bank File Roles
| File          | Purpose (keep Markdown headers)                                        |
| ------------- | ---------------------------------------------------------------------- |
| **README.md** | Product context, architecture, tech stack, key files, API contracts    |
| **TASKS.md**  | Living checklist (phases, tasks, reference files, learnings, new deps) |
---
#### 10  Updating the Memory Bank
- You MUST review ALL core memory bank files (ai-memory/README.md, ai-memory/TASKS.md) for necessary updates.
- Process:
  1. Execute a suitable command to get a project file listing:
     ```bash
     find . -maxdepth 4 -type f -name "*.py" -o -name "*.md" -o -name "*.yaml" -o -name "*.toml" | grep -v -E "(\.venv|__pycache__|\.git|\.pytest_cache|\.vscode|node_modules|logs|.*egg-info|\.ruff_cache|\.benchmarks|data)" | sort
     ```
  2. Identify key files and folders that need to be explored and add them to the 'Key Repository Folders and Files' section of ai-memory/README.md.
  3. Based on the file listing and recent project activity, identify other key project files (e.g., main application entry points, core modules, critical configuration files) that might require reading or re-reading to ensure ai-memory/README.md (especially 'System Patterns' and 'Tech Context') is comprehensive and up-to-date. Create a ai-memory/TASKS.md file with a list of files and folders to traverse. Include frequent tasks to "update the ai-memory/README.md" as part of the tasks list. Balance reading a group of 3 or 4 files before updating the ai-memory/README.md but waiting too long for updates.
  4. Execute the ai-memory/TASKS.md and check off tasks that are completed. If you identify new key files or folders that need to be read during execution, update the ai-memory/TASKS.md file.
  5. Record architectural decisions, API changes, and performance optimizations in README.md.
  6. Ask the user if there are other folders or files that need to be explored.
---
#### Tools
1. Use `uv add` to add python packages
2. Use `alembic` for database migrations
3. Use `ruff check` and `ruff format` for code quality
4. Use `mypy` for type checking
5. Make sure to ALWAYS run activate before the command. 

**Keep all replies short, technical, and complete.**
```