#### 1  Python / FastAPI Coding Rules

* **Functions over classes**. `def` for sync, `async def` for I/O.
* **Full type hints**; validate with **Pydantic v2** models.
* **RORO** pattern (receive object, return object).
* `lower_snake_case` for files/dirs; verbs in variables (`is_valid`).
* Guard-clause error handling; no nested `else`.
* Raise `HTTPException` for expected errors; log + wrap unexpected ones.
* Folder layout:

  ```
  app/
    routers/      # route groups
    models/       # Pydantic + DB
    utils/        # pure helpers
    types/        # shared aliases
    static/
  ```

---

#### 2  FastAPI Best Practices

* Use **lifespan** context, not `startup/shutdown` events.
* Inject DB/session with dependencies.
* Middleware: logging, tracing, error capture.
* All DB and external calls are **async**.
* Cache hot data (e.g., Redis).
* Feature-flag rollouts and graceful rollback paths.

---

#### 3  Performance & Ops

* Eliminate blocking I/O in routes.
* Track latency, throughput; emit metrics + alerts.
* Optimize (de)serialization with Pydantic config.

---

#### 4  Dependencies

* fastapi, pydantic-v2, asyncpg or aiomysql, sqlalchemy-2.0 (optional).
* google-genai (not google-generativeai).
* Package with **uv**:

  ```bash
  uv pip install <pkg>
  source .venv/bin/activate
  ```

---

#### 5  Memory-Bank Workflow (Stateless Agent)

1. **At session start** read:
   `ai-memory/README.md`, `PROMPT.md`, `TASKS.md`.
2. **Treat `README.md` as canonical context.
3. **Maintain `TASKS.md`**:

   * Fine-grained tasks with `- [ ]` / `- [x]`.
   * Last task in every phase â†’ record key learnings before reset.
4. **Propose updates** to memory files whenever you add patterns, finish major work, or clarify requirements.
5. **Missing folder?** Create `ai-memory/`, stub the three files, notify user.

---

#### 6  Memory-Bank File Roles

| File          | Purpose (keep Markdown headers)                                        |
| ------------- | ---------------------------------------------------------------------- |
| **README.md** | Product context, architecture, tech stack, key files                   |
| **TASKS.md**  | Living checklist (phases, tasks, reference files, learnings, new deps) |

---

#### 7  Updating the Memory Bank

- You MUST review ALL core memory bank files (ai-memory/README.md, ai-memory/PROMPT.md, ai-memory/TASKS.md) for necessary updates.
- Process:
  1. Execute a suitable command to get a project file listing (e.g. find . -maxdepth 4 -type f -not -path "./node_modules/*" -not -path "./vendor/*" -not -path "./.git/*").
  2. Identify key files and folders that need to be explored and add them to the 'Key Repository Folders and Files' section of ai-memory/README.md.
  3. Based on the file listing and recent project activity, identify other key project files (e.g., main application entry points, core modules, critical configuration files) that might require reading or re-reading to ensure ai-memory/README.md (especially 'System Patterns' and 'Tech Context') is comprehensive and up-to-date. Create a ai-memory/TASKS.md file with a list of files and folders to traverse. Include frequent tasks to "update the ai-memory/README.md" as part of the tasks list. Balance reading a group of 3 or 4 files before updating the ai-memory/README.md but waiting too long for updates.
  4. Execute the ai-memory/TASKS.md and check off tasks that are completed. If you identify new key files or folders that need to be read during execution, update the ai-memory/TASKS.md file.
  5. Ask the user if there are other folders or files that need to be explored.

---

Tools
1. use `uv add` to add python packages. 

**Keep all replies short, technical, and complete.**
