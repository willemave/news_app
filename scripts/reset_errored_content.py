#!/usr/bin/env python3
"""
Reset errored or stuck articles/podcasts for re-processing.
This script:
1. Finds articles/podcasts with 'failed' status OR stuck in 'processing' status
2. Optionally includes 'completed' content missing a summary
3. Optionally filters by date range
4. Resets status to 'new' and clears error data
5. Creates new processing tasks for the content

Note: Only processes articles and podcasts, not news items.
"""

import argparse
import os
import sys
from datetime import UTC, datetime, timedelta

# Add parent directory to path for imports (use os.path for Python 3.13 compatibility)
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from sqlalchemy import create_engine, func, or_
from sqlalchemy.orm import sessionmaker

from app.core.settings import get_settings
from app.models.schema import Content, ContentStatus, ProcessingTask


def parse_datetime(value: str) -> datetime:
    """Parse a datetime string in various formats.

    Supports:
        - ISO format: 2024-01-15T10:30:00
        - Date only: 2024-01-15 (assumes start of day)
        - Date and time: 2024-01-15 10:30
    """
    formats = [
        "%Y-%m-%dT%H:%M:%S",
        "%Y-%m-%d %H:%M:%S",
        "%Y-%m-%dT%H:%M",
        "%Y-%m-%d %H:%M",
        "%Y-%m-%d",
    ]
    for fmt in formats:
        try:
            return datetime.strptime(value, fmt)
        except ValueError:
            continue
    raise argparse.ArgumentTypeError(
        f"Invalid datetime format: {value}. Use YYYY-MM-DD or YYYY-MM-DD HH:MM"
    )


def reset_errored_content(
    days: int | None = None,
    since: datetime | None = None,
    until: datetime | None = None,
    stuck_hours: float | None = None,
    missing_summary: bool = False,
    dry_run: bool = False,
):
    """Reset errored or stuck articles/podcasts for re-processing.

    Args:
        days: Only reset content errored within this many days (None = all errored content)
        since: Only reset content errored on or after this datetime
        until: Only reset content errored before this datetime
        stuck_hours: Also include content stuck in 'processing' for more than X hours
        missing_summary: Also include 'completed' content that's missing a summary
        dry_run: If True, show what would be reset without making changes
    """
    # Get database settings
    settings = get_settings()

    # Create engine and session
    engine = create_engine(settings.database_url)
    SessionLocal = sessionmaker(bind=engine, autocommit=False, autoflush=False)

    with SessionLocal() as db:
        try:
            # Only process articles and podcasts, not news
            allowed_types = ["article", "podcast"]
            print(f"Filtering to content types: {', '.join(allowed_types)}")

            # Build query for errored content and optionally stuck processing content
            status_conditions = [Content.status == ContentStatus.FAILED.value]

            # Add stuck processing condition if specified
            if stuck_hours is not None:
                stuck_cutoff = datetime.now(UTC) - timedelta(hours=stuck_hours)
                stuck_condition = (Content.status == ContentStatus.PROCESSING.value) & (
                    Content.updated_at < stuck_cutoff
                )
                status_conditions.append(stuck_condition)
                print(f"Including content stuck in 'processing' for more than {stuck_hours} hours")

            # Add missing summary condition if specified
            if missing_summary:
                # Content is 'completed' but has no summary in metadata
                # Use json_extract for SQLite compatibility
                missing_summary_condition = (Content.status == ContentStatus.COMPLETED.value) & (
                    func.json_extract(Content.content_metadata, "$.summary").is_(None)
                )
                status_conditions.append(missing_summary_condition)
                print("Including 'completed' content missing a summary")

            query = db.query(Content).filter(
                Content.content_type.in_(allowed_types), or_(*status_conditions)
            )

            # Add date filters
            if days:
                cutoff_date = datetime.now(UTC) - timedelta(days=days)
                query = query.filter(Content.updated_at >= cutoff_date)
                cutoff_str = cutoff_date.strftime("%Y-%m-%d %H:%M:%S")
                print(f"Filtering to content errored since {cutoff_str} UTC")
            if since:
                query = query.filter(Content.updated_at >= since)
                since_str = since.strftime("%Y-%m-%d %H:%M:%S")
                print(f"Filtering to content errored on or after {since_str}")
            if until:
                query = query.filter(Content.updated_at < until)
                print(f"Filtering to content errored before {until.strftime('%Y-%m-%d %H:%M:%S')}")

            # Get errored/stuck content
            affected_content = query.all()

            if not affected_content:
                print("No errored, stuck, or incomplete content found matching criteria")
                return

            # Count by status for reporting
            failed_count = sum(
                1 for c in affected_content if c.status == ContentStatus.FAILED.value
            )
            stuck_count = sum(
                1 for c in affected_content if c.status == ContentStatus.PROCESSING.value
            )
            missing_summary_count = sum(
                1 for c in affected_content if c.status == ContentStatus.COMPLETED.value
            )
            print(f"Found {len(affected_content)} content items to reset:")
            if failed_count:
                print(f"  - {failed_count} with 'failed' status")
            if stuck_count:
                print(f"  - {stuck_count} stuck in 'processing' status")
            if missing_summary_count:
                print(f"  - {missing_summary_count} 'completed' but missing summary")

            if dry_run:
                print("\nDRY RUN - Would reset the following content:")
                for content in affected_content[:20]:  # Show first 20 in dry run
                    ctype = content.content_type
                    status = content.status
                    print(f"  - ID: {content.id}, Type: {ctype}, Status: {status}")
                    print(f"    Source: {content.source}, URL: {content.url[:60]}...")
                    if content.error_message:
                        print(f"    Error: {content.error_message[:100]}...")
                if len(affected_content) > 20:
                    print(f"  ... and {len(affected_content) - 20} more")
                return

            # Delete existing processing tasks for affected content
            content_ids = [c.id for c in affected_content]
            deleted_tasks = (
                db.query(ProcessingTask)
                .filter(ProcessingTask.content_id.in_(content_ids))
                .delete(synchronize_session=False)
            )
            print(f"Deleted {deleted_tasks} existing processing tasks")

            # Reset content status and clear error data
            reset_count = 0
            new_tasks = []

            for content in affected_content:
                # Capture original status before reset
                original_status = content.status

                # Reset content fields
                content.status = ContentStatus.NEW.value
                content.error_message = None
                content.retry_count = 0
                content.checked_out_by = None
                content.checked_out_at = None
                content.processed_at = None
                # Keep content_metadata as it may contain useful partial data

                # Create new processing task
                task = ProcessingTask(
                    task_type="process_content",
                    content_id=content.id,
                    status="pending",
                    payload={
                        "content_type": content.content_type,
                        "url": content.url,
                        "source": content.source,
                        "reset_from_status": original_status,
                        "original_error": content.error_message[:500]
                        if content.error_message
                        else None,
                    },
                )
                new_tasks.append(task)
                reset_count += 1

            # Add all new tasks
            db.add_all(new_tasks)

            # Commit all changes
            db.commit()

            print(f"\nSuccessfully reset {reset_count} content items")
            print(f"Created {len(new_tasks)} new processing tasks")
            print("\nYou can now run 'python scripts/run_workers.py' to process the reset content")

            # Show summary by content type
            type_counts: dict[str, int] = {}
            for content in affected_content:
                type_counts[content.content_type] = type_counts.get(content.content_type, 0) + 1

            print("\nContent reset by type:")
            for content_type, count in sorted(type_counts.items()):
                print(f"  - {content_type}: {count}")

        except Exception as e:
            db.rollback()
            print(f"Error: {e}")
            raise


def main():
    parser = argparse.ArgumentParser(
        description="Reset errored or stuck articles/podcasts for re-processing",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Reset all failed articles/podcasts
  python scripts/reset_errored_content.py

  # Reset failed + stuck + missing summary content from last 14 days
  python scripts/reset_errored_content.py --days 14 --stuck-hours 24 --missing-summary

  # Reset content stuck in 'processing' for 24+ hours
  python scripts/reset_errored_content.py --stuck-hours 24

  # Reset 'completed' content that's missing a summary
  python scripts/reset_errored_content.py --missing-summary

  # Dry run to see what would be reset
  python scripts/reset_errored_content.py --days 14 --stuck-hours 24 --missing-summary --dry-run

  # Reset content errored since a specific date
  python scripts/reset_errored_content.py --since 2024-12-01

Note: Only processes articles and podcasts, not news items.
        """,
    )

    parser.add_argument(
        "--days",
        type=int,
        help="Only reset content errored within this many days (default: all errored content)",
    )

    parser.add_argument(
        "--since",
        type=parse_datetime,
        help="Only reset content errored on or after this datetime (YYYY-MM-DD)",
    )

    parser.add_argument(
        "--until",
        type=parse_datetime,
        help="Only reset content errored before this datetime (YYYY-MM-DD or YYYY-MM-DD HH:MM)",
    )

    parser.add_argument(
        "--stuck-hours",
        type=float,
        help="Also reset content stuck in 'processing' status for more than X hours",
    )

    parser.add_argument(
        "--missing-summary",
        action="store_true",
        help="Also reset 'completed' content that's missing a summary",
    )

    parser.add_argument(
        "--dry-run", action="store_true", help="Show what would be reset without making changes"
    )

    args = parser.parse_args()

    # Validate conflicting options
    if args.days and (args.since or args.until):
        parser.error("Cannot use --days together with --since/--until")

    if args.dry_run:
        print("DRY RUN MODE - No changes will be made\n")

    reset_errored_content(
        days=args.days,
        since=args.since,
        until=args.until,
        stuck_hours=args.stuck_hours,
        missing_summary=args.missing_summary,
        dry_run=args.dry_run,
    )


if __name__ == "__main__":
    main()
